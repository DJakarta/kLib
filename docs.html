<!DOCTYPE HTML>

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>kLib Documentation</title>
		<link rel="stylesheet" href="styles/docs.css" />
		<script type="text/javascript" src="scripts/sizzle.js"></script>
		<script type="text/javascript" src="scripts/jquery.js"></script>
		<script type="text/javascript" src="scripts/kLib.js"></script>
		<meta charset="UTF-8" />
		<base target="_blank">
	</head>
	
	<body>
		<section unselectable="on" class="header">
			<header id="pageTitle" unselectable="on" class="header">
				kLib Documentation
				<div unselectable="on" class="header"> 
					<span unselectable="on" class="header">
						*work in progress
					</span>
				</div>
			</header>
		</section>
		
		<section id="articleSection">
			<article>
				<h1>
					Library Basic Info
				</h1>
				<article>
					<h2>
						Basics
					</h2>
					<article>
						<h3>
							Accessing the library
						</h3>
						The whole library is stored in the <code>kLib</code> object. For simplified writing, the <code>$k</code> object has a reference to the library. Therefore, functions can be accessed just like the object's properties and methods, in the following ways:
						<code class="block">
							kLib.debug.writeToConsole('text');
						</code>
						<aside>
							The <code>kLib</code> object is the real object.
						</aside>
						<code class="block">
							$k.debug.writeToConsole('text');
						</code>
						<aside>
							The <code>$k</code> object has a reference to the <code>kLib</code> object.
						</aside>
					</article>
					<article>
						<h3>
							Reference and function linking
						</h3>
						The <code>kLib</code> object itself is structured in a task-related way. For example, the information about the library can be accessed from the <code>kLib.basicInfo</code> object, and the <code>writeToConsole()</code> function from the <code>kLib.debug</code> object.
						However, for simplified code writing, the commonly used functions are linked directly to the main object, and some even to the window object, like so:
						<code class="block">
							cWrite('something');
						</code>
					</article>
				</article>
				<article>
					<h2>
						Version Properties And Methods
					</h2>
					<article>
						<h3>
							Version
						</h3>
						The version number is a string stored in the <code>version</code> property of the <code>basicInfo</code> object, containing a number with 1 decimal. It can be retrieved as a normal property:
						<code class="block">
							version=$k.basicInfo.version;
							cWrite(version, true);
						</code>
						<aside>
							Since it is stored in a string, conversion to number is recommended before using it in mathematical calculations.
						</aside>
					</article>
					<article>
						<h3>
							Build
						</h3>
						The build number is a string stored in the <code>build</code> property of the <code>basicInfo</code> object, containing a two digit integer. It can be retrieved as a normal property:
						<code class="block">
							build=$k.basicInfo.build;
							cWrite(build, true);
						</code>
						<aside>
							Since it is stored in a string, conversion to number is recommended before using it in mathematical calculations.
						</aside>
					</article>
					<article>
						<h3>
							Stage
						</h3>
						The stage of the library is a string stored in the <code>stage</code> property of the <code>basicInfo</code> object. It can be retrieved as a normal property:
						<code class="block">
							stage=$k.basicInfo.stage;
							cWrite(stage, true);
						</code>
						<aside>
							The stage property can be one of the following:
							<table>
								<tr>
									<th>
										stage name
									</th>
									<th>
										explanation
									</th>
								</tr>
								<tr>
									<td>
										Final
									</td>
									<td>
										Final state; only minor changes will be made from here
									</td>
								</tr>
								<tr>
									<td>
										Beta
									</td>
									<td>
										Almost completed; most of the features working
									</td>
								</tr>
								<tr>
									<td>
										Testing
									</td>
									<td>
										Pre-Beta version; the functions are tested for bugs before the definitive release
									</td>
								</tr>
								<tr>
									<td>
										Alpha
									</td>
									<td>
										Uncompleted version, but basic functions working; may have bugs
									</td>
								</tr>
								<tr>
									<td>
										onWork
									</td>
									<td>
										First versions; some of the basics may not be implemented yet
									</td>
								</tr>
							</table>
						</aside>
					</article>
					<article>
						<h3>
							Build date
						</h3>
						The build date is a string stored in the <code>buildDate</code> property of the <code>basicInfo</code> object. It can be retrieved as a normal property:
						<code class="block">
							buildDate=$k.basicInfo.buildDate;
							cWrite(buildDate, true);
						</code>
						<aside>
							The string has the the ISO Date format (<code>YYYY-MM-DD</code>).
						</aside>
					</article>
					<article>
						<h3>
							Version info
						</h3>
						The <code>getFullVersionInfo()</code> method returns a string containing a series of version properties.
						<code class="block">
							fullInfo=$k.basicInfo.getFullVersionInfo();
							cWrite(fullInfo, true);
						</code>
					</article>
				</article>
			</article>
			<article>
				<h1>
					Extension Of Standard JavaScript
				</h1>
				<article>
					<h2>
						Strings
					</h2>
					<article>
						<h3>
							Word delimitators
						</h3>
						String methods use custom kLib word separator characters to delimitate words. The string formed by any number of these in any order is considered a delimiter. Any substring between two delimiters is considered a word.
						<aside>
							These are the characters used to delimitate words:
							<table>
								<tr>
									<th>
										character
									</th>
									<th>
										explanation
									</th>
								</tr>
								<tr>
									<td>
										_
									</td>
									<td>
										the underscore
									</td>
								</tr>
								<tr>
									<td>
										-
									</td>
									<td>
										the dash
									</td>
								</tr>
								<tr>
									<td>
										\s
									</td>
									<td>
										any whitespace character matched by the JavaScript RegExp
									</td>
								</tr>
							</table>
						</aside>
					</article>
					<article>
						<h3>
							Quickly find first and last character
						</h3>
						To speed up coding, kLib adds the <code>.firstChar()</code> and the <code>.lastChar()</code> methods to the default string object, which return the character from the first and last position in the string.
						<code class="block">
							myString='1 2 a b # $';
							cWrite(myString.firstChar()+' is the first, there\'s something in between, and the last one is '+myString.lastChar(), true);
						</code>
					</article>
					<article>
						<h3>
							Converting to camelCase
						</h3>
						kLib extends the functionality of the String object by creating a <code>.toCamelCase()</code> method. It works by deleting any word delimiter and converting the next character to uppercase.
						<code class="block">
							myString='this string will be converted to camelCase!';
							cWrite(myString.toCamelCase(), true);
							myString2='--353 --Some _random $ _/ -    !~ 9text 33_TextT.me -sa -=dd';
							cWrite(myString2.toCamelCase());
						</code>
					</article>
					<article>
						<h3>
							Converting to dash-case
						</h3>
						kLib extends the functionality of the String object by creating a <code>.toDashCase()</code> method. It works by replacing any word delimiter with a dash.
						<code class="block">
							myString='this string will be converted to dash-case!';
							cWrite(myString.toDashCase(), true);
							myString2='--353 --Some _random $ _/ -    !~ 9text 33_TextT.me -sa -=dd';
							cWrite(myString2.toDashCase());
						</code>
					</article>
					<article>
						<h3>
							Converting to underscore_case
						</h3>
						kLib extends the functionality of the String object by creating a <code>.toUnderscoreCase()</code> method. It works by replacing any word delimiter with an underscore.
						<code class="block">
							myString='this string will be converted to underscore_case!';
							cWrite(myString.toUnderscoreCase(), true);
							myString2='--353 --Some _random $ _/ -    !~ 9text 33_TextT.me -sa -=dd';
							cWrite(myString2.toUnderscoreCase());
						</code>
					</article>
					<article>
						<h3>
							Converting to $JSON_Case
						</h3>
						kLib extends the functionality of the String object by creating a <code>.toJSONCase()</code> method. It works by deleting any character not accepted in JavaScript variable names and removing all numbers from the beginning of the strings.
						<code class="block">
							myString='this string will be converted to $JSON_case!';
							cWrite(myString.toJSONCase(), true);
							myString2='--353 --Some _random $ _/ -    !~ 9text 33_TextT.me -sa -=dd';
							cWrite(myString2.toJSONCase());
						</code>
						<aside>
							JavaScript standards allow for more valid characters in variable naming, but <code>.toJSONCase()</code> method will only allow the most commonly used ones, presented bellow:
							<table>
								<tr>
									<th>
										character
									</th>
									<th>
										explanation
									</th>
								</tr>
								<tr>
									<td>
										_
									</td>
									<td>
										the underscore
									</td>
								</tr>
								<tr>
									<td>
										$
									</td>
									<td>
										the dollar sign
									</td>
								</tr>
								<tr>
									<td>
										[A-z]
									</td>
									<td>
										any letters from uppercase A to lowercase z matched by the JavaScript RegExp
									</td>
								</tr>
								<tr>
									<td>
										[0-9]
									</td>
									<td>
										any digits from 0 to 9 matched by the JavaScript RegExp (not at the beginning of the string)
									</td>
								</tr>
							</table>
						</aside>
					</article>
					<article>
						<h3>
							Case differences
						</h3>
						You can use the following code to see the difference between cases:
						<code class="block">
							myString='see the difference!';
							myString2='--353 --Some _random $ _/ -    !~ 9text 33_TextT.me -sa -=dd';
							cWrite(
								'original:\n'+myString
								+'\n\n.toCamelCase():\n'+myString.toCamelCase()
								+'\n\n.toDashCase():\n'+myString.toDashCase()
								+'\n\n.toUnderscoreCase():\n'+myString.toUnderscoreCase()
								+'\n\n.toJSONCase():\n'+myString.toJSONCase()
							, true);
							cWrite(
								'----------------------\n'
								+'original:\n'+myString2
								+'\n\n.toCamelCase():\n'+myString2.toCamelCase()
								+'\n\n.toDashCase():\n'+myString2.toDashCase()
								+'\n\n.toUnderscoreCase():\n'+myString2.toUnderscoreCase()
								+'\n\n.toJSONCase():\n'+myString2.toJSONCase()
							);
						</code>
					</article>
					<article>
						<h3>
							Space trimming
						</h3>
						To trim the leading or trailing whitespace characters from a string, use <code>.trimSpaces</code>. It does not modify the actual string, only returning a new one.
						<code class="block">
							myString='  some spaces there-   ';
							cWrite(
								'original:\n'+myString
								+'\n\n.trimSpaces():\n'+myString.trimSpaces()
							, true);
						</code>
					</article>
					<article>
						<h3>
							Finding a substring
						</h3>
							To check if at least one substring is present in a string, use <code>.find(substring)</code>. It can take any number of arguments, both strings and regular expressions. The function returns <code>true</code> if any of the arguments is matched in the string, <code>false</code> otherwise.
						<code class="block">
							myString='matching here some-things';
							cWrite(myString.find('match'), true);
							cWrite(myString.find(/ing/g));
							cWrite(myString.find('summer', 'here'));
							cWrite(myString.find('matter', 'no'));
							cWrite(myString.find(/\,/, /\s/, /\./));
						</code>
					</article>
					<article>
						<h3>
							Counting
						</h3>
							To count the occurance number of one or more characters, a substrings or a regular expressions in a string, use <code>.count(character)</code>. In case of multiple arguments, it returns the total match count.
						<code class="block">
							myString='let us and he count theu Es and Xs';
							cWrite(myString.count('e'), true);
							cWrite(myString.count('x'));
							cWrite(myString.count('he'));
							cWrite(myString.count(/e[^t]*t/g));
							cWrite(myString.count(/e[^t]*t/g, 'e', 'he', 'x'));
						</code>
					</article>
				</article>
				<article>
					<h2>
						Numbers
					</h2>
					<article>
						<h3>
							Leading Zeroes
						</h3>
						One can add zeroes to the beginning of a number by using the <code>.leadingZeroes(n)</code> method. The function adds zeroes in front of the number until the total length of the resulting string (including the '-' or '.' symbols) equals the argument given. It returns a string.
						<code class="block">
							three=3;
							threePointTwo=3.2;
							minusThree=-3;
							minusThreePointTwo=-3.2;
							cWrite(three.leadingZeroes(5), true);
							cWrite(threePointTwo.leadingZeroes(5));
							cWrite(minusThree.leadingZeroes(5));
							cWrite(minusThreePointTwo.leadingZeroes(5));
						</code>
					</article>
					<article>
						<h3>
							Number types
						</h3>
						To check if a number is an integer, use the <code>.isInteger()</code> method.
						<code class="block">
							three=3;
							threePointTwo=3.2;
							minusThree=-3;
							cWrite(three.isInteger(), true);
							cWrite(threePointTwo.isInteger());
							cWrite(minusThree.isInteger());
						</code>
					</article>
				</article>
				<article>
					<h2>
						Arrays
					</h2>
					<article>
						<h3>
							indexOf
						</h3>
						If an <code>.indexOf</code> method is not present, the library adds one. It behaves just like the standard one.
						<code class="block">
							arr=['one', 'two', 'three'];
							cWrite(arr.indexOf('two'), true);
							cWrite(arr.indexOf('three'));
							cWrite(arr.indexOf('four'));
							cWrite(arr.indexOf('one', 1));
							cWrite(arr.indexOf('two', -1));
						</code>
					</article>
					<article>
						<h3>
							Finding elements
						</h3>
						You can see if an object is present in an array by using the <code>.find(obj)</code> method. It returns <code>true</code> if the element is found, <code>false</code> otherwise. It compares using strict equality.
						<code class="block">
							arr=['one', 'two', 'three'];
							cWrite(arr.find('two'), true);
							cWrite(arr.find('three'));
							cWrite(arr.find('four'));
						</code>
						To chech if any one element is found, use <code>.findAny(obj)</code>. If any of its given arguments are found, it returns true.
						<code class="block">
							arr=['one', 'two', 'three'];
							cWrite(arr.findAny('two', 'monkey'), true);
							cWrite(arr.findAny('three'));
							cWrite(arr.findAny('four'));
						</code>
					</article>
					<article>
						<h3>
							Removing elements
						</h3>
						You can remove the first occurance of an object present in an array by using the <code>.remove(obj)</code> method. It returns <code>true</code> if the element is found at least once, <code>false</code> otherwise. It is compares using strict equality.
						<code class="block">
							arr=['one', 'two', 'three', 'three', 'four'];
							cWrite(arr.remove('three'), true);
							cWrite(arr.remove('five'));
							cWrite(arr);
						</code>
						The function also accepts a second boolean argument, and if evaluated to true, it will remove all the occurences of the object in the array, not just the first.
						<code class="block">
							arr=['one', 'two', 'three', 'three', 'four'];
							cWrite(arr.remove('three', true), true);
							cWrite(arr);
						</code>
					</article>
				</article>
			</article>
			<article>
				<h1>
					General Functions
				</h1>
				<article>
					<h2>
						Console Functions
					</h2>
					<article>
						<h3>
							Using the console
						</h3>
						To ease developement, kLib can create a simple console to which you can write text and debug your code. To write to the console, you can use the long <code>kLib.debug.writeToConsole()</code> or the short <code>cWrite()</code>.
						<code class="block">
							kLib.debug.writeToConsole('text');
						</code>
						<code class="block">
							cWrite('text');
						</code>
						The functions accept 2 arguments. The first one is required, being the text to be written, and the second one is an optional boolean value which, when true, will overwrite the console with the new text. Notice how leaving the last argument blank, or setting it to 0 makes no difference, but any value that evaluates to the boolean true will overwrite the console.
						<code class="block">
							cWrite('writing1');
							cWrite('writing2', 0);
							cWrite('writing3', null);
							cWrite('writing4', undefined);
						</code>
						<code class="block">
							cWrite('overwriting1', 1);
						</code>
						<code class="block">
							cWrite('overwriting2', 'nothing but true');
						</code>
						<aside>
							The console has a maximum of 200 row count. Exceed that, and rows from the top will be deleted.
						</aside>
					</article>
					<article>
						<h3>
							Closing the console
						</h3>
						You can close the console directly from JavaScript by calling the long <code>kLib.debug.closeConsole()</code> function or the short <code>cClose()</code> function. You can also manually close the console by double-clicking it. Open the console from above and try it below:
						<code class="block">
							kLib.debug.closeConsole();
						</code>
						<code class="block">
							cClose();
						</code>
						The functions accept 1 boolean argument that, when evaluated to true (same as the overwriting argument from above), will clear the console at exit. If the argument is false or missing, at write time, the console will continue from previously existing text.
						<code class="block">
							cClose(1);
						</code>
					</article>
				</article>
				<article>
					<h2>
						Math functions
					</h2>
					<article>
						<h3>
							Finite numbers
						</h3>
						You can check if a number is finite by using <code>kLib.math.isFinite(obj)</code>.
						<code class="block">
							num1=[3, 'f'];
							num2=NaN;
							num3=33;
							num4=Infinity;
							cWrite(kLib.math.isFinite(num1), true);
							cWrite(kLib.math.isFinite(num2));
							cWrite(kLib.math.isFinite(num3));
							cWrite(kLib.math.isFinite(num4));
						</code>
						You can check if multiple objects are all finite numbers using <code>kLib.math.areFinite()</code>.
						<code class="block">
							num1=[3, 'f'];
							num2=NaN;
							num3=33;
							num4=Infinity;
							cWrite(kLib.math.areFinite(num1, num2, num3, num4), true);
							cWrite(kLib.math.areFinite(num3));
						</code>
						<aside class="TD">
							Binding these to window
						</aside>
					</article>
					<article>
						<h3>
							Integers
						</h3>
						In a similar way, one can check if objects are integers using <code>kLib.math.isInteger(obj)</code>.
						<code class="block">
							num1=[3, 'f'];
							num2=3.11;
							num3=33;
							num4=-1;
							cWrite(kLib.math.isInteger(num1), true);
							cWrite(kLib.math.isInteger(num2));
							cWrite(kLib.math.isInteger(num3));
							cWrite(kLib.math.isInteger(num4));
						</code>
						You can check if multiple objects are all integers using <code>kLib.math.areIntegers()</code>.
						<code class="block">
							num1=[3, 'f'];
							num2=3.11;
							num3=33;
							num4=-1;
							cWrite(kLib.math.areFinite(num1, num2, num3, num4), true);
							cWrite(kLib.math.areFinite(num3, num4));
						</code>
						<aside class="TD">
							Binding these to window
						</aside>
					</article>
				</article>
			</article>
			<article>
				<h1>
					User Agent
				</h1>
				<article>
					<h2>
						Properties
					</h2>
					<article>
						<h3>
							Accessing and refreshing
						</h3>
						All the properties are saved in <code>kLib.UA</code>. If, for any reason, you want to refresh these, you can do it by calling <code>kLib.UA.getUAInfo()</code> method.
						<code class="block">
							kLib.UA.getUAInfo();
						</code>
					</article>
					<article>
						<h3>
							Browser Name
						</h3>
						The browser name is stored in the <code>name</code> property.
						<code class="block">
							cWrite($k.UA.name, true);
						</code>
						<aside>
							It can be one of the following, in the order of searching:
							<table>
								<tr>
									<th>
										value
									</th>
									<th>
										case
									</th>
								</tr>
								<tr>
									<td>
										Internet Explorer
									</td>
									<td>
										any version of; found by <code>window.ActiveXObject</code>
									</td>
								</tr>
								<tr>
									<td>
										Opera
									</td>
									<td>
										any version of; found by <code>window.opera</code>
									</td>
								</tr>
								<tr>
									<td>
										Chrome
									</td>
									<td>
										any version of; found by <code>window.chrome</code>
									</td>
								</tr>
								<tr>
									<td>
										Safari
									</td>
									<td>
										any version of; found by <code>window.WebKitAnimationEvent && !window.chrome</code>
									</td>
								</tr>
								<tr>
									<td>
										Konqueror
									</td>
									<td>
										any version of; found by <code>window.clientInformation</code>
									</td>
								</tr>
								<tr>
									<td>
										SeaMonkey
									</td>
									<td>
										any version of; found by <code>window.mozRequestAnimationFrame && window.navigator.userAgent.indexOf('SeaMonkey')!=-1</code>
									</td>
								</tr>
								<tr>
									<td>
										Firefox
									</td>
									<td>
										any version of; found by <code>window.mozRequestAnimationFrame && window.navigator.userAgent.indexOf('Firefox')!=-1</code>
									</td>
								</tr>
								<tr>
									<td>
										Camino
									</td>
									<td>
										any version of; found by <code>window.XPCSafeJSObjectWrapper</code>
									</td>
								</tr>
								<tr>
									<td>
										Unknown
									</td>
									<td>
										if none of the above matched
									</td>
								</tr>
							</table>
						</aside>
					</article>
					<article>
						<h3>
							Browser Short Name
						</h3>
						The browser short name (made from initials) is stored in the <code>short</code> property.
						<code class="block">
							cWrite($k.UA.short, true);
						</code>
						<aside>
							It can be one of the following, for the above browser names:
							<table>
								<tr>
									<th>
										value
									</th>
									<th>
										case
									</th>
								</tr>
								<tr>
									<td>
										IE
									</td>
									<td>
										Internet Explorer
									</td>
								</tr>
								<tr>
									<td>
										O
									</td>
									<td>
										Opera
									</td>
								</tr>
								<tr>
									<td>
										CH
									</td>
									<td>
										Chrome
									</td>
								</tr>
								<tr>
									<td>
										S
									</td>
									<td>
										Safari
									</td>
								</tr>
								<tr>
									<td>
										K
									</td>
									<td>
										Konqueror
									</td>
								</tr>
								<tr>
									<td>
										SM
									</td>
									<td>
										SeaMonkey
									</td>
								</tr>
								<tr>
									<td>
										FF
									</td>
									<td>
										Firefox
									</td>
								</tr>
								<tr>
									<td>
										C
									</td>
									<td>
										Camino
									</td>
								</tr>
								<tr>
									<td>
										UK
									</td>
									<td>
										Unknown
									</td>
								</tr>
							</table>
						</aside>
					</article>
					<article>
						<h3>
							Browser Version
						</h3>
						The browser version is stored as a number in the <code>version</code> property.
						<code class="block">
							cWrite($k.UA.version, true);
						</code>
					</article>
					<article>
						<h3>
							Browser
						</h3>
						A pre-made browser name and version string is stored in <code>browser</code> property.
						<code class="block">
							cWrite($k.UA.browser, true);
						</code>
					</article>
					<article>
						<h3>
							Agent
						</h3>
						A pre-made browser short name and version string is stored in <code>agent</code> property.
						<code class="block">
							cWrite($k.UA.agent, true);
						</code>
					</article>
				</article>
			</article>
			<article>
				<h1>
					Colors
				</h1>
				<article>
					<h2>
						Namespace
					</h2>
					<article>
						<h3>
							Color constructor
						</h3>
						One can create colors using the <code>new kLib.color.Color()</code> constructor, or the shorthand <code>new Color()</code>.
					</article>
					<article>
						<h3>
							Color functions
						</h3>
						Color functions are stored as methods of the <code>Color</code> constructor.
						<code class="block">
							Color.parse('#ffff00');
						</code>
					</article>
					<article>
						<h3>
							Color prototype
						</h3>
						Once a color is created, one can access its methods and properties from the <code>Color</code>'s prototype.
						<code class="block">
							a=new Color();
							cWrite(a.toHEX(), true);
						</code>
					</article>
				</article>
				<article>
					<h2>
						Native Format Support
					</h2>
					<article>
						<h3>
							Checking for support
						</h3>
						To see if a specific format is natively supported by the browser, you can use the <code>Color.supports()</code> method. Given a format identifier string, it will return <code>true</code> if it is supported or <code>false</code> otherwise.
						<code class="block">
							cWrite(Color.supports('rgb'), true);
						</code>
						One can also check the array where that info is stored internally, at <code>kLib.color.support</code>.
						<code class="block">
							cWrite(kLib.color.support, true);
						</code>
						If by any reason this gets modified, one can refresh it using the internal method <code>kLib.color.checkForSupport()</code>.
						<code class="block">
							cWrite(kLib.color.support, true);
							kLib.color.support.remove('hex');
							cWrite(kLib.color.support);
							kLib.color.checkForSupport();
							cWrite(kLib.color.support);
						</code>
						<aside>
							This also changes the default format in which a color is converted to string.
						</aside>
					</article>
					<article>
						<h3>
							Current possible native formats
						</h3>
						Current available formats in browsers are <code>hex</code>, <code>rgb</code>, <code>rgba</code>, <code>hsl</code> and <code>hsla</code>.
					</article>
				</article>
				<article>
					<h2>
						Library Formats
					</h2>
					<article>
						<h3>
							Formats supported
						</h3>
						The library adds support for some formats even though they are not natively supported by the browser.
						<aside>
							The following formats are supported:
							<table>
								<tr>
									<th>
										identifier
									</th>
									<th>
										full format name
									</th>
									<th>
										example (opaque yellow)
									</th>
								</tr>
								<tr>
									<td>
										<code>hex</code>
									</td>
									<td>
										Hexadecimal RGB
									</td>
									<td>
										<code>#ffff00</code>
									</td>
								</tr>
								<tr>
									<td>
										<code>rgb</code>
									</td>
									<td>
										Red Green Blue
									</td>
									<td>
										<code>rgb(255, 255, 0)</code>
									</td>
								</tr>
								<tr>
									<td>
										<code>rgba</code>
									</td>
									<td>
										Red Green Blue Alpha
									</td>
									<td>
										<code>rgba(255, 255, 0, 1)</code>
									</td>
								</tr>
								<tr>
									<td>
										<code>hsl</code>
									</td>
									<td>
										Hue Saturation Lightness
									</td>
									<td>
										<code>hsl(60, 100%, 50%)</code>
									</td>
								</tr>
								<tr>
									<td>
										<code>hsla</code>
									</td>
									<td>
										Hue Saturation Lightness Alpha
									</td>
									<td>
										<code>hsla(60, 100%, 50%, 1)</code>
									</td>
								</tr>
							</table>
						</aside>
					</article>
					<article>
						<h3>
							Hexadecimal RBG
						</h3>
						The <code>hex</code> format has the following syntax: <code>#RRGGBB</code>. <code>RR</code> is the red component, <code>GG</code> is the green component and <code>BB</code> is the blue component, all in hexadecimal base, between <code>0x00</code> (<code>0</code>) and <code>0xff</code> (<code>255</code>).
					</article>
					<article>
						<h3>
							Red Green Blue
						</h3>
						The <code>rgb</code> format has the following syntax: <code>rgb(R, G, B)</code>. <code>R</code> is the red component, <code>G</code> is the green component and <code>B</code> is the blue component, all between <code>0</code> and <code>255</code>.
					</article>
					<article>
						<h3>
							Red Green Blue Alpha
						</h3>
						The <code>rgba</code> format has the following syntax: <code>rgba(R, G, B, A)</code>. It is composed just like ordinary <code>rgb</code>, but with the extra <code>A</code> component representing the alpha value (opacity of the color), between <code>0</code> and <code>1</code>.
					</article>
					<article>
						<h3>
							Hue Saturation Lightness
						</h3>
						The <code>hsl</code> format has the following syntax: <code>hsl(H, S%, L%)</code>. <code>H</code> is the hue component between <code>0</code> and <code>359</code>, <code>S</code> is the saturation and <code>L</code> is the lightness of the color, between <code>0</code> and <code>100</code>.
					</article>
					<article>
						<h3>
							Hue Saturation Lightness Alpha
						</h3>
						The <code>hsla</code> format has the following syntax: <code>hsla(H, S%, L%, A)</code>. It is composed just like ordinary <code>hsl</code>, but with the extra <code>A</code> component representing the alpha value (opacity of the color), between <code>0</code> and <code>1</code>.
					</article>
				</article>
				<article>
					<h2>
						Basics
					</h2>
					<article>
						<h3>
							Creating a color
						</h3>
						You can create a new color object by calling the Color constructor.
						<code class="block">
							a=new Color();
							cWrite(a, true);
						</code>
					</article>
					<article>
						<h3>
							Ways of creating a color
						</h3>
						As you can see from above, calling the <code>Color</code> constructor without arguments defaults the color to opaque black. In order to create a custom color, you can pass it a color string.
						<code class="block">
							a=new Color('#ffffff');
							cWrite(a, true);
						</code>
						You can also instantiate a color by specifying its three main components (RGB/HSL), an optional opacity value (which defaults to <code>1</code> when not set), and a format identifier (which when not set defaults to <code>rgb</code>).
						<code class="block">
							a=new Color(10, 10, 10, 'rgb');
							b=new Color(10, 10, 10);
							c=new Color(0x0a, 0x0a, 0x0a, 'hex');
							d=new Color(10, 10, 10, 1);
							e=new Color(10, 10, 10, 1, 'rgb');
							f=new Color(140, 1, 20, 'rgb');
							g=new Color();
							cWrite(a, true);
							cWrite(b);
							cWrite(c);
							cWrite(d);
							cWrite(e);
							cWrite(f);
							cWrite(g);
						</code>
					</article>
					<article>
						<h3>
							Converting to string
						</h3>
						You can convert a color object to a color string by using <code>.toRGB()</code>, <code>.toRGBA()</code>, <code>.toHSL()</code>, <code>.toHSLA()</code>, <code>.toHEX()</code> and <code>.toString()</code>
						<code class="block">
							a=new Color();
							cWrite(a.toRGB(), true);
							cWrite(a.toRGBA());
							cWrite(a.toHSL());
							cWrite(a.toHSLA());
							cWrite(a.toHEX());
							cWrite(a.toString());
						</code>
					</article>
					<article>
						<h3>
							Default format
						</h3>
						The default format in which <code>.toString()</code> outputs is the first of the formats supported by the browser, in the followind order: <code>hsla</code>, <code>rgba</code>, <code>hsl</code>, <code>rgb</code> and <code>hex</code>. One can change that by using the <code>Color.defaultTo(format)</code> method, passing it the identifier of the desired format.
						<code class="block">
							a=new Color();
							cWrite(a.toString(), true);
							Color.defaultTo('rgb');
							cWrite(a.toString());
							Color.defaultTo('hex');
							cWrite(a.toString());
						</code>
					</article>
				</article>
				<article>
					<h2>
						Modifying a color
					</h2>
					<article>
						<h3>
							Changing a color property
						</h3>
						You change a property by a selected value using <code>.change(property, value)</code>, the <code>property</code> argument being a string definig the full name or first letter of the property, and the <code>value</code> being a finite number, which will be added to the property. The other values will be automatically recalculated.
						<code class="block">
							a=new Color(100, 50, 50, 'hsl');
							cWrite(a.toHSL(), true);
							a.change('hue', 100);
							cWrite(a.toHSL());
							a.change('h', -50);
							cWrite(a.toHSL());
						</code>
						You set a property by a selected value using <code>.set(property, value)</code>. As above, the other values will be automatically recalculated.
						<code class="block">
							a=new Color(100, 50, 50, 'hsl');
							cWrite(a.toHSL(), true);
							cWrite(a.toRGB());
							a.set('hue', 50);
							cWrite(a.toHSL());
							cWrite(a.toRGB());
							a.set('h', -50);
							cWrite(a.toHSL());
							cWrite(a.toRGB());
						</code>
					</article>
				</article>
			</article>
			<article>
				<h1>
					Collections
				</h1>
				<article>
					<h2>
						Querying The DOM
					</h2>
					<article>
						<h3>
							Basics
						</h3>
						You select elements using the <code>kLib</code> or <code>$k</code> functions.
						<code class="block">
							$k('h1');
						</code>
						The function returns a new <code>kLib.QuerySelection</code> instance, a collection of elements.
						<code class="block">
							sel=$k('h1');
							cWrite(sel, true);
							cWrite(sel instanceof kLib.QuerySelection);
						</code>
					</article>
					<article>
						<h3>
							Context
						</h3>
						If the first argument is a string, the function also takes a second argument, which specifies the context of the search (only returns elements in the specified elements). Must be a HTML element, a string representing a css query, a collection or an array in collection format. It can be simply left blank, searching by default in the <code>document</code> object.
						<code class="block">
							a=[$k('head')[0]];
							b=$k('body');
							cClose(1);
							cWrite($k('script')+'\n');
							cWrite($k('script', 'section')+'\n');
							cWrite($k('script', a)+'\n');
							cWrite($k('script', b)+'\n');
						</code>
					</article>
				</article>
				<article>
					<h2>
						Container objects
					</h2>
					<article>
						<h3>
							Container structure
						</h3>
						The object returned is made out of two main parts: details about the search and object holder. The objects are indexed from <code>0</code> to <code>container.length-1</code>, and, together with the <code>container.length</code> property, they form the object holder.
						<code class="block">
							sel=$k('section');
							cWrite(sel.length, true);
							for (i=0; i&lt;sel.length; i++) {
								cWrite(i+'. '+sel[i]);
							}
						</code>
						The <code>container.query</code> and <code>container.context</code> properties store the query object and the context respectively.
						<code class="block">
							sel=$k('section', $k('body')[0]);
							cWrite(sel.query, true);
							cWrite(sel.context);
						</code>
					</article>
					<article>
						<h3>
							Query object
						</h3>
						The first argument isn't necesserly a string. In the case it is a string, the function queries the DOM with browser built-in methods, and fills the container with matching elements, creating a collection.
						<code class="block">
							sel=$k('article');
							cWrite(sel, true);
						</code>
						<aside>
							The collection can be easely inspected by converting it to string.
						</aside>
						If it is an array or another object of instance <code>kLib.QuerySelection</code>, the function acts as a wrapper, returning a collection indexed the same as the original, but with the container's properties and methods.
						<code class="block">
							sel1=$k(['one', 'two']);
							sel2=$k($k('h1'));
							cWrite(sel1+'\n', true);
							cWrite(sel2);
						</code>
						Else, it returns a collection made from the arguments, in the encountered order.
						<code class="block">
							a={'one': '1', 'two': '2'};
							b=$k('section');
							c=[[3], [1,2]];
							d='script';
							sel=$k(a, b, c, d);
							cWrite(sel, true);
						</code>
						<aside>
							It adds elements to the collection as follows:
							<table>
								<tr>
									<th>
										case
									</th>
									<th>
										explanation
									</th>
								</tr>
								<tr>
									<td>
										collection
									</td>
									<td>
										each of the elements in collection is added separately in the holder
									</td>
								</tr>
								<tr>
									<td>
										array
									</td>
									<td>
										each of the elements in the array is added separately in the holder
									</td>
								</tr>
								<tr>
									<td>
										string
									</td>
									<td>
										it is treated as a query, with each element from the returned collection being added separately in the holder
									</td>
								</tr>
								<tr>
									<td>
										others
									</td>
									<td>
										each object added in the holder
									</td>
								</tr>
							</table>
						</aside>
					</article>
					<article>
						<h3>
							Converting to string
						</h3>
						To convert a collection to string, simply use <code>.toString()</code> method.
						<code class="block">
							a=$k('section').toString();
							cWrite(a, true);
						</code>
						<aside>
							The string is made from <code>query</code>, <code>context</code>, <code>length</code> and the object holder.
						</aside>
					</article>
					<article>
						<h3>
							Iterating thru a collection
						</h3>
						To iterate thru a collection, use <code>.forEach(fn, arguments)</code> method. It calls the function for each of the elements in the collection, with the <code>this</code> keyword referring to the current element. The <code>arguments</code> parameter is optional. If present, it must be an array containing the arguments with which the function will be called.
						<code class="block">
							a=$k('h1');
							fn=function (extraParam) {
								extraParam=typeof extraParam==='undefined' ? '' : extraParam;
								cWrite(this+': '+this.innerText.trimSpaces()+'\n'+extraParam);
							};
							a.forEach(fn);
							cWrite('\n\n\n');
							a.forEach(fn, ['sth extra']);
						</code>
					</article>
				</article>
				<article>
					<h2>
						Adding elements to existing collection
					</h2>
					<article>
						<h3>
							Concatenation
						</h3>
						You can append multiple objects and collections by using the <code>.concat()</code> method.
						<code class="block">
							sel=$k('section');
							obj={'one': 1};
							sel.concat(obj);
							cWrite(sel, true);
						</code>
						If an argument is an array or another object of instance <code>kLib.QuerySelection</code>, the function appends each one of it's elements. If it is a string, it executes it as a query and appends the returned collection's elements.
						<code class="block">
							sel=$k('section');
							sel2=$k('h1');
							arr=['33', 44];
							str='body';
							obj={'the': 'best'};
							sel.concat(sel2, arr, str, undefined, obj);
							cWrite(sel, true);
						</code>
						<aside>
							Concatenation removes the <code>context</code> and <code>query</code> properties from the collection.
						</aside>
					</article>
					<article>
						<h3>
							Joining elements
						</h3>
						To simply join elements to a collection, without worrying whether they will be converted or not, use the <code>.join()</code> method.
						<code class="block">
							a=$k('section');
							a.join('body', $k('head'), [3, 4]);
							cWrite(a, true);
						</code>
					</article>
				</article>
			</article>
			<article>
				<h1>
					DOM Manipulation
				</h1>
				<article>
					<h2>
						DOM Collections
					</h2>
					<article>
						<h3>
							Check for non-DOM elements
						</h3>
						To check if a collection only contains DOM elements, use <code>.isDOM()</code> method. It returns true if all are DOM elements, false if at least one isn't. <code>document</code> and <code>window</code> objects are treated as DOM elements.
						<code class="block">
							a=$k('section');
							a.join([3, 4]);
							b=$k('section');
							cWrite(a.isDOM(), true);
							cWrite(b.isDOM());
						</code>
					</article>
				</article>
				<article>
					<h2>
						Creating and appending to the DOM
					</h2>
					<article>
						<h3>
							Creating elements
						</h3>
						To create elements from plain HTML strings, use query function with the first argument being a HTML string. It only works for a single element.
						<code class="block">
							a=$k('&lt;section&gt;');
							cWrite(a, true);
						</code>
						If the string is more complex than a simple tag with no attributes, it lets the browser <code>innerHTML</code> handle the creation, returning only the first element created.
						<code class="block">
							a=$k('&lt;section id="sec"&gt;&lt;/section&gt;');
							cWrite(a[0].id, true);
							cWrite(a);
						</code>
						The function supports a second argument, being an object from which to initialize the attributes of the element.
						<code class="block">
							a=$k('&lt;section id="sec"&gt;&lt;/section&gt;', {'class': 'something', 'id': 'interesting'});
							cWrite('class: '+a[0].class, true);
							cWrite('id: '+a[0].id);
							cWrite(a);
						</code>
						<aside>
							Since the initialization takes place after the creation of the element, it has priority over the string specified attributes.
						</aside>
					</article>
					<article>
						<h3 class="NYI">
							Appending elements
						</h3>
						To append one or more elements to each of the elements in a collection, use the <code>.append()</code> method.
						<code class="block">
						</code>
						To append each element from the collection to one or more elements, use the <code>.appendTo()</code> method.
						<code class="block">
						</code>
					</article>
					<article>
						<h3 class="NYI">
							Prepending elements
						</h3>
						To prepend one or more elements to each of the elements in a collection, use the <code>.prepend()</code> method.
						<code class="block">
						</code>
						To prepend each element from the collection to one or more elements, use the <code>.prependTo()</code> method.
						<code class="block">
						</code>
					</article>
				</article>
			</article>
			<article>
				<h1>
					Events
				</h1>
				<article>
					<h2>
						Registering and unregistering handlers
					</h2>
					<article>
						<h3>
							Registering
						</h3>
						You can register event handlers to elements by using the <code>.on(name, function, capture)</code> function. The <code>name</code> is a string representing the type of the event, the <code>function</code> is a function representing the handler and the <code>capture</code> sets the capture or bubbling (see <a href="http://www.quirksmode.org/js/events_order.html">this</a> for details).
						<code class="block">
							fn=function () {
								cWrite('clicked');
							};
							$k('img').on('click', fn, false);
						</code>
						<aside>
							The <code>capture</code> argument is optional. If not present, it is set to <code>false</code>. Non-boolean values are accepted and converted to their boolean counterparts. In IE&lt;=8, only bubbling is supported.
						</aside>
					</article>
					<article>
						<h3>
							Unregistering
						</h3>
						Unregistering is done the same as registering. You can unregister event handlers to elements by using the <code>.off(name, function, capture)</code> function. It will work only if all three arguments correspond. If no corresponding function is found, it does not throw any errors.
						<code class="block">
							fn=function () {
								cWrite('clicked');
							};
							$k('img').off('click', fn, false);
						</code>
					</article>
				</article>
			</article>
		</section>		
		<script type="text/javascript" src="scripts/docs.js" id="script"></script>
	</body>
</html>